
#ifndef __GNET_DBCHANGEROLENAME_HPP
#define __GNET_DBCHANGEROLENAME_HPP

#include "rpcdefs.h"
#include "callid.hxx"
#include "state.hxx"

#include "dbchangerolenamearg"
#include "dbchangerolenameres"
#include "grolenamehis"

namespace GNET
{

class DBChangeRolename : public Rpc
{
#define	RPC_BASECLASS	Rpc
	#include "dbchangerolename"
#undef	RPC_BASECLASS

	void CheckKingdomName(int roleid, const Octets & newname)
	{
		try
		{
			StorageEnv::Storage * pkingdom = StorageEnv::GetStorage("kingdom");
			StorageEnv::CommonTransaction txn;
			Marshal::OctetsStream key, value;
			try
			{
				key << 0;
				if (!pkingdom->find(key, value, txn))
					return;
				GKingdomInfo kingdom;
				value >> kingdom;
				bool dirty = false;
				if (kingdom.king.roleid == roleid)
				{
					kingdom.king.rolename = newname;
					dirty = true;
				}
				else if (kingdom.queen.roleid == roleid)
				{
					kingdom.queen.rolename = newname;
					dirty = true;
				}
				else
				{
					std::vector<GKingdomFunctionary>::iterator it, ite = kingdom.functionaries.end();
					for (it = kingdom.functionaries.begin(); it != ite; ++it)
					{
						if (it->roleid == roleid)
						{
							it->rolename = newname;
							dirty = true;
							break;
						}
					}
				}
				if (dirty)
					pkingdom->insert(key, Marshal::OctetsStream()<<kingdom, txn);
			}
			catch ( DbException e ) { throw; }
			catch ( ... )
			{
				DbException ee( DB_OLD_VERSION );
				txn.abort( ee );
				throw ee;
			}
		}
		catch ( DbException e )
		{
			Log::log( LOG_ERR, "CheckKingdomName what=%s\n", e.what() );
		}
	}
	void Server(Rpc::Data *argument, Rpc::Data *result, Manager *manager, Manager::Session::ID sid)
	{
		DBChangeRolenameArg *arg = (DBChangeRolenameArg *)argument;
		DBChangeRolenameRes *res = (DBChangeRolenameRes *)result;
		LOG_TRACE( "DBChangeRolename, roleid=%d itemid=%d item_pos=%d", arg->roleid, arg->itemid, arg->item_pos);

		try
		{
			StorageEnv::Storage * prolename = StorageEnv::GetStorage("rolename");
			StorageEnv::Storage * pbase = StorageEnv::GetStorage("base");
//			StorageEnv::Storage * pstatus = StorageEnv::GetStorage("status");
			StorageEnv::Storage * pinventory = StorageEnv::GetStorage("inventory");
			StorageEnv::Storage * puser = (arg->syncdata.data_mask&SYNC_CASHUSED)?StorageEnv::GetStorage("user"):NULL;
			//StorageEnv::Storage * pstore = (arg->syncdata.data_mask&SYNC_STOTEHOUSE)?StorageEnv::GetStorage("storehouse"):NULL;
			StorageEnv::Storage * pstore = StorageEnv::GetStorage("storehouse");
			StorageEnv::Storage * pfamily = StorageEnv::GetStorage("family");
			StorageEnv::Storage * psect = StorageEnv::GetStorage("sect");
			StorageEnv::Storage * psnsplayer = StorageEnv::GetStorage("snsplayerinfo");
			StorageEnv::Storage * pcircle = StorageEnv::GetStorage("circle");
			StorageEnv::Storage * prolenamehis = StorageEnv::GetStorage("rolenamehis");

			StorageEnv::CommonTransaction txn;
			try
			{
				Marshal::OctetsStream krole, os_rolename;
				if (prolename->find(arg->newname, os_rolename, txn))
				{
					res->retcode = ERR_DUPLICATRECORD;
					return;
				}
				krole << arg->roleid;
				GRolePocket pocket;
				Marshal::OctetsStream(pinventory->find(krole, txn)) >> pocket;
				if (arg->syncdata.inventory.timestamp - pocket.timestamp <= 0)
				{
					Log::log(LOG_ERR,"DBChangeRolename, timestamp mismatch. roleid=%d (%d<%d)",
							arg->roleid, arg->syncdata.inventory.timestamp, pocket.timestamp);
					DbException ee(DB_VERIFY_BAD);
					txn.abort(ee);
					throw ee;
				}
				if (!DecPocketItemInPos(arg->syncdata.inventory.items, arg->item_pos, arg->itemid, 1, res->syncdata.inventory.items))
				{
					Log::log(LOG_ERR,"DBChangeRolename, dec item fail. roleid=%d", arg->roleid);
					DbException ee(DB_VERIFY_BAD);
					txn.abort(ee);
					throw ee;
				}
				pinventory->insert(krole, Marshal::OctetsStream()<<arg->syncdata.inventory, txn);

				GRoleBase base;
				Marshal::OctetsStream(pbase->find(krole, txn)) >> base; 
				Octets oldname = base.name;
				base.name = arg->newname;
				pbase->insert(krole, Marshal::OctetsStream()<<base, txn);

				//prolename->insert(old_name, Marshal::OctetsStream() << (int)-1, txn);//老名字仍可以映射到roleid
				prolename->insert(arg->newname, krole, txn);

				if (base.familyid > 0)
				{
					Marshal::OctetsStream kfamily, os_family;
					GFamily family;
					kfamily << base.familyid;
					if (pfamily->find(kfamily, os_family, txn))
					{
						os_family >> family;
						GFolkVector::iterator it, ite = family.member.end();
						for (it = family.member.begin(); it != ite; ++it)
						{
							if ((int)it->rid == arg->roleid)
							{
								it->name = arg->newname;
								break;
							}
						}
						pfamily->insert(kfamily, Marshal::OctetsStream() << family, txn);
					}
				}

				if (base.sectid > 0)
				{
					Marshal::OctetsStream ksect, os_sect;
					GSect sect;
					ksect << base.sectid;
					if (psect->find(ksect, os_sect, txn))
					{
						os_sect >> sect;
						if (arg->roleid == base.sectid)
						{
//							if (sect.name == oldname)
								sect.name = arg->newname;
						}
						else
						{
							GDiscipleVector::iterator it, ite = sect.disciples.end();
							for (it = sect.disciples.begin(); it != ite; ++it )
							{
								if (it->roleid == arg->roleid)
								{
									it->name = arg->newname;
									break;
								}
							}
						}
						psect->insert(ksect, Marshal::OctetsStream() << sect, txn);
					}
				}

				Marshal::OctetsStream hisos = base.circletrack;
				if(hisos.size()>0)
				{
					std::vector<GCircleHistoryDB> HisVec;
					hisos >> HisVec;
					if(HisVec.size()>0)
					{
						res->circleid = HisVec.back().circleid;
						Marshal::OctetsStream kcircle, os_circle;
						if (pcircle->find(kcircle, os_circle, txn))
						{
							GCircleDB circle;
							os_circle >> circle;
							std::vector<GCircleMemberDB>::iterator it, ite = circle.member.end();
							for (it = circle.member.begin(); it != ite; ++it)
							{
								if ((int)it->roleid == arg->roleid)
								{
									it->name = arg->newname;
									break;
								}
							}
							pcircle->insert(kcircle, Marshal::OctetsStream() << circle, txn);
						}
					}
				}
				Marshal::OctetsStream os_snsplayer;
				if (psnsplayer->find(krole, os_snsplayer, txn))
				{
					GSNSPlayerInfoCache snsplayer;
					os_snsplayer >> snsplayer;
					snsplayer.roleinfo.rolename = arg->newname;
					if (arg->roleid == base.sectid)
						snsplayer.roleinfo.sectname = arg->newname;
					snsplayer.playerinfo.rolename = arg->newname;
					psnsplayer->insert(krole, Marshal::OctetsStream() << snsplayer, txn);
				}

				Marshal::OctetsStream key_all, value_all, value_rolenamehis;
				key_all << (int)0;
				std::map<int, Octets> name_map;
				if (prolenamehis->find(key_all, value_all, txn))
					value_all >> name_map;
				name_map[arg->roleid] = arg->newname;
				prolenamehis->insert(key_all, Marshal::OctetsStream() << name_map, txn);
				GRoleNameHisVector rolenamehis_vec;
				if (prolenamehis->find(krole, value_rolenamehis, txn))
					value_rolenamehis >> rolenamehis_vec;
//				if (rolenamehis_vec.size() >= MAX_ROLENAME_RECORD)
//					rolenamehis_vec.erase(rolenamehis_vec.begin());
				rolenamehis_vec.push_back(GRoleNameHis(oldname, Timer::GetTime()));
				prolenamehis->insert(krole, Marshal::OctetsStream() << rolenamehis_vec, txn);

				int money_delta = arg->syncdata.inventory.money - pocket.money;
				::UpdateCash(puser, arg->syncdata, txn);
				//::UpdateShoplog(plog, arg->syncdata, txn);
				::UpdateStore(arg->roleid, pstore, arg->syncdata, txn, money_delta);
				res->syncdata.inventory.money = arg->syncdata.inventory.money;
				res->syncdata.data_mask = arg->syncdata.data_mask;
//				res->oldname = oldname;
				res->rolenamehis = rolenamehis_vec;
				res->familyid = base.familyid;
				res->sectid = base.sectid;
				res->retcode = ERR_SUCCESS;
				Log::formatlog("dbchangerolename", "roleid=%d itemid=%d item_pos=%d",
						arg->roleid, arg->itemid, arg->item_pos);
			}
			catch ( DbException e ) { throw; }
			catch ( ... )
			{
				DbException ee( DB_OLD_VERSION );
				txn.abort( ee );
				throw ee;
			}
		}
		catch ( DbException e )
		{
			Log::log( LOG_ERR, "DBChangeRolename, roleid=%d, what=%s\n", arg->roleid, e.what() );
			res->retcode = ERR_VERIFYFAILED;
		}
		if (res->retcode == ERR_SUCCESS)
			CheckKingdomName(arg->roleid, arg->newname);
	}

	void Client(Rpc::Data *argument, Rpc::Data *result, Manager *manager, Manager::Session::ID sid)
	{
		// TODO
		// DBChangeRolenameArg *arg = (DBChangeRolenameArg *)argument;
		// DBChangeRolenameRes *res = (DBChangeRolenameRes *)result;
	}

	void OnTimeout()
	{
		// TODO Client Only
	}

};

};
#endif
