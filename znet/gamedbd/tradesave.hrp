
#ifndef __GNET_TRADESAVE_HPP
#define __GNET_TRADESAVE_HPP

#include "rpcdefs.h"
#include "callid.hxx"
#include "state.hxx"
#include "dbbuffer.h"
#include "tradesavearg"
#include "tradesaveres"
#include "gamedbmanager.h"

#include <vector>

namespace GNET
{

class TradeSave : public Rpc
{
#define	RPC_BASECLASS	Rpc
	#include "tradesave"
#undef	RPC_BASECLASS

	struct InventoryCompare
	{
		bool operator() (const GRoleInventory &x, const GRoleInventory &y) const
		{ return x.pos < y.pos; }
	};

	void Server(Rpc::Data *argument, Rpc::Data *result, Manager *manager, Manager::Session::ID sid)
	{
		TradeSaveArg *arg = (TradeSaveArg *)argument;
		TradeSaveRes *res = (TradeSaveRes *)result;
		Marshal::OctetsStream key1, key2;

		LOG_TRACE( "TradeSave, roleid1=%d, roleid2=%d.\n", arg->roleid1, arg->roleid2 );
		GameDBManager::GetInstance()->UpdateTradeMoney( arg->money1, arg->money2 );

		try
		{
			StorageEnv::Storage * pinventory = StorageEnv::GetStorage("inventory");
			StorageEnv::CommonTransaction txn;
			try
			{
				GRolePocket bag1, bag2;
				GRoleInventoryVector items;
				std::map<unsigned int, unsigned int> verify;
				key1 << arg->roleid1;
				key2 << arg->roleid2;
				Marshal::OctetsStream( pinventory->find( key1, txn ) ) >> bag1;
				Marshal::OctetsStream( pinventory->find( key2, txn ) ) >> bag2;
				if(bag1.money+bag2.money!=arg->money1+arg->money2)
				{
					Log::log( LOG_ERR, "TradeSave,role1=%d,role2=%d,money1=%d,money2=%d,arg1=%d,arg2=%d",
						arg->roleid1,arg->roleid2,bag1.money,bag1.money,arg->money1,arg->money2);
					throw DbException(DB_VERIFY_BAD);
				}
				bag1.money = arg->money1;
				bag2.money = arg->money2;

				GRoleInventoryVector::iterator it,ie;
				for(it=bag1.items.begin(),ie=bag1.items.end();it!=ie;++it)
					verify[it->id] += it->count;
				for(it=bag2.items.begin(),ie=bag2.items.end();it!=ie;++it)
					verify[it->id] += it->count;

				std::vector<GRoleInventory>::iterator iv,ive;
				for(iv=arg->goods1.begin(),ive=arg->goods1.end();iv!=ive;++iv)
					verify[iv->id] -= iv->count;
				for(iv=arg->goods2.begin(),ive=arg->goods2.end();iv!=ive;++iv)
					verify[iv->id] -= iv->count;
				for(std::map<unsigned int, unsigned int>::iterator i=verify.begin(),e=verify.end();i!=e;++i)
				{
					if(i->second!=0)
					{
						Log::log( LOG_ERR, "TradeSave, roleid=%d,roleid2=%d, item=%d count=%d\n",
							arg->roleid1, arg->roleid2, i->first, i->second);
						throw DbException(DB_VERIFY_BAD);
					}
				}
				bag1.items.GetVector().swap(arg->goods1);
				bag2.items.GetVector().swap(arg->goods2);

				pinventory->insert( key1, Marshal::OctetsStream() << bag1, txn );
				pinventory->insert( key2, Marshal::OctetsStream() << bag2, txn );
				res->retcode = ERR_SUCCESS;
			}
			catch ( DbException e ) { throw; }
			catch ( ... )
			{
				DbException ee( DB_OLD_VERSION );
				txn.abort( ee );
				throw ee;
			}
		}
		catch ( DbException e )
		{
			Log::log( LOG_ERR, "TradeSave, roleid=%d,roleid2=%d, what=%s\n",
							arg->roleid1, arg->roleid2, e.what() );
			res->retcode = ERR_TRADE_DB_FAILURE;
		}
	}

	void Client(Rpc::Data *argument, Rpc::Data *result, Manager *manager, Manager::Session::ID sid)
	{
		// TradeSaveArg *arg = (TradeSaveArg *)argument;
		// TradeSaveRes *res = (TradeSaveRes *)result;
	}

	void OnTimeout()
	{
	}

};

};
#endif
