
#ifndef __GNET_USERLOGIN_HPP
#define __GNET_USERLOGIN_HPP

#include "rpcdefs.h"
#include "callid.hxx"
#include "state.hxx"
#include "userloginarg"
#include "userloginres"

#include "gdeliveryserver.hpp"
#include "onlineannounce.hpp"
#include "kickoutuser.hpp"
#include "queryuserprivilege2.hpp"
#include <algorithm>
#include "announceforbidinfo.hpp"
#include "mapremaintime.h"
#include "mapforbid.h"
#include "mapuser.h"
#include "maprewardtype.h"
#include "gauthclient.hpp"

namespace GNET
{

class UserLogin : public ProxyRpc
{
	GNET::Protocol *Clone() const {  return new UserLogin(*this); }
public:
	enum { PROTOCOL_TYPE = RPC_USERLOGIN };
	UserLogin(Type type, Rpc::Data *argument, Rpc::Data *result)
		: ProxyRpc(type, argument, result ) { }
	UserLogin(const UserLogin &rhs) : ProxyRpc(rhs) { }
	int  PriorPolicy( ) const { return 101; }
	bool SizePolicy(size_t size) const { return size <= 128; }
	bool TimePolicy(int timeout) const { return timeout <= 30; }

	void TryLogin(UserLoginArg& arg)
	{
		//if GAuth is not available, let the user login directly
		//step1. check out whether kickout user
		bool useronline=false;
		bool remoteonline=false;
		unsigned int _localsid=0;
		{
			Thread::RWLock::RDScoped l(UserContainer::GetInstance().GetLocker());
			UserInfo * pinfo = UserContainer::GetInstance().FindUser(arg.userid);
			if (NULL != pinfo)
			{
				useronline = true;
				_localsid = pinfo->localsid;
				if (pinfo->status == _STATUS_REMOTE_LOGIN)
					remoteonline = true;
			}
		}
		if (useronline)
		{
			if (arg.blkickuser) 
			{
				LOG_TRACE("UserLogin: kick out previous login, userid=%d", arg.userid); 
				KickoutUser ku(arg.userid,_localsid);
				//Process中还会对gdsm->locker_map加锁，因此不能放在Thread::RWLock::WRScoped中
				ku.Process(NULL,0); 
			}
			else
			{
				SetResult(UserLoginRes(ERR_MULTILOGIN));
				SendToSponsor();
				return;
			}
		}
		UserContainer::GetInstance().UserLogin(arg.userid,proxy_sid, arg.localsid,false, 0, 0, arg.loginip, arg.iseckey, arg.oseckey, arg.accountname);
		if (remoteonline)
		{
			UserInfo * pinfo = UserContainer::GetInstance().FindUser(arg.userid);
			if (pinfo)
				pinfo->status = _STATUS_REMOTE_LOGIN;
		}
		SetResult(UserLoginRes(ERR_SUCCESS,0));
		SendToSponsor();
		STAT_MIN5("Login", 1);
	}
	bool CheckLoginCondition(Manager::Session::ID proxy_sid, UserLoginArg& arg)
	{
		/* if game master forbid user login, login failed */
		{
			if (!ForbidLogin::GetInstance().IsLoginAllowedGlobal())
			{
				SetResult(UserLoginRes(ERR_SRVMAINTAIN));
				SendToSponsor();
				return false;	
			}
		}
		{
			GRoleForbid	forbid;
			if( ForbidLogin::GetInstance().GetForbidLogin( arg.userid, forbid ) )
			{
				GDeliveryServer::GetInstance()->Send(proxy_sid,AnnounceForbidInfo(arg.userid,arg.localsid,forbid));
				SetResult(UserLoginRes(ERR_ACCOUNTFORBID));
				SendToSponsor();
				return false;	
			}
		}
		/* if game server is handling user, login is forbidden */
		if (ForbiddenUsers::GetInstance().IsExist(arg.userid))
		{
			SetResult(UserLoginRes(ERR_ACCOUNTLOCKED));
			SendToSponsor();
			return false;
		}
		if (RemoteLoggingUsers::GetInstance().IsExist(arg.userid))
		{
			SetResult(UserLoginRes(ERR_ACCOUNTLOCKED));
			SendToSponsor();
			return false;
		}
		/* if online user exceed max player number, refuse new connection */
		{
			if ( UserContainer::GetInstance().Size() >= UserContainer::GetInstance().GetPlayerLimit() )
			{
				SetResult(UserLoginRes(ERR_SERVEROVERLOAD));
				SendToSponsor();
				return false;
			}	   
		}
		return true;
	}
	bool Delivery( Manager::Session::ID proxy_sid, OctetsStream & osArg )
	{
		UserLoginArg arg;
		osArg >> arg;

		{
			Thread::RWLock::RDScoped l(UserContainer::GetInstance().GetLocker());
			UserInfo * pinfo = UserContainer::GetInstance().FindUser(arg.userid);
			if(pinfo && !arg.blkickuser)
			{
				SetResult(UserLoginRes(ERR_MULTILOGIN));
				SendToSponsor();
				return false;
			}
		}
		if (!CheckLoginCondition(proxy_sid,arg))
			return false;
		
		if( GAuthClient::GetInstance()->SendProtocol( *this ) )
		{
			//DEBUG_PRINT("gdelivery::Send to Auth server successfully.\n");
			return true;
		}
		else
		{
			TryLogin(arg);			
			return false;
		}
	}

	void PostProcess( Manager::Session::ID proxy_sid, const OctetsStream & osArg, const OctetsStream & osRes )
	{
		UserLoginArg arg;
		osArg >> arg;
		UserLoginRes res;
		osRes >> res;
		DEBUG_PRINT("gdelivery::userlogin,user=%d,proxy=%d,localsid=%d,ret=%d,isgm=%d,func=%d,"
			"param=%d,free=%d,remain=%d\n",arg.userid,proxy_sid,arg.localsid,res.retcode,
			res.blIsGM,res.func,res.funcparm,res.free_time_left,res.remain_playtime);
		if (res.retcode!=ERR_SUCCESS)
			return;
		GDeliveryServer* gdsm=GDeliveryServer::GetInstance();

		//if user still in usermap, run KickoutUser
		//同步修改 TryLogin
		bool useronline=false;
		bool remoteonline=false;
		unsigned int _localsid=0;
		{
			Thread::RWLock::RDScoped l(UserContainer::GetInstance().GetLocker());
			UserInfo * pinfo = UserContainer::GetInstance().FindUser(arg.userid);
			if (NULL != pinfo)
			{
				useronline = true;
				_localsid = pinfo->localsid;
				if (pinfo->status == _STATUS_REMOTE_LOGIN)
					remoteonline = true;
			}
		}
		if ( useronline )
		{
			LOG_TRACE("UserLogin: kick out previous login, userid=%d", arg.userid); 
			KickoutUser ku(arg.userid,_localsid); //会将 pinfo 删除
			ku.Process(NULL,0); //Process中还会对gdsm->locker_map加锁，因此不能放在Thread::RWLock::WRScoped中
		}
		UserContainer::GetInstance().UserLogin(arg.userid,proxy_sid, arg.localsid,res.blIsGM, res.func, res.funcparm, arg.loginip, arg.iseckey, arg.oseckey, arg.accountname);
		if (remoteonline)
		{
			//考虑踢跨服角色失败的情况 KickoutRemoteUser 如果失败了 要能发起下一次强踢操作
			UserInfo * pinfo = UserContainer::GetInstance().FindUser(arg.userid);
			if (pinfo)
				pinfo->status = _STATUS_REMOTE_LOGIN;
		}
		//if user is a GM, query user's privilege
		if (res.blIsGM != 0)
		{
			GAuthClient::GetInstance()->SendProtocol(QueryUserPrivilege2(arg.userid,gdsm->zoneid));
		}
		// announce sellpoint forbid info to client
		STAT_MIN5("Login", 1);
	}

	void OnTimeout( const OctetsStream & osArg )
	{
		UserLoginArg arg;
		osArg >> arg;
		TryLogin(arg);
	}

};

};
#endif
