
#ifndef __GNET_PLAYERIDENTITYMATCH_HPP
#define __GNET_PLAYERIDENTITYMATCH_HPP

#include "rpcdefs.h"
#include "callid.hxx"
#include "state.hxx"
#include "playeridentitymatcharg"
#include "playeridentitymatchres"
#include "gamedbclient.hpp"
#include "forbid.hxx"
#include "gmshutuprole.hpp"
#include "getuser.hrp"
#include "centraldeliveryclient.hpp"
#include "centraldeliveryserver.hpp"
#include "queryuserprivilege_re.hpp"
#include "gmshutup.hpp"

namespace GNET
{

class PlayerIdentityMatch : public ProxyRpc
{
#define	RPC_BASECLASS	ProxyRpc
	#include "playeridentitymatch"
#undef	RPC_BASECLASS

	void HandleRoleForbid(GRoleInfo & roleinfo)
	{
		GRoleForbidVector & forbid=roleinfo.forbid;
		int time_left=0;
		for (size_t i=0;i<forbid.size();i++)
		{
			//与GetRoleInfo保持一致
			time_left=forbid[i].createtime+forbid[i].time-time(NULL);
			if (time_left<=0) continue;
			switch (forbid[i].type)
			{
				case Forbid::FBD_FORBID_TALK:
					LinkServer::GetInstance().BroadcastProtocol(GMShutupRole(_ROLE_INVALID,_SID_INVALID,
								roleinfo.id,time_left,forbid[i].reason));
					break;
				case Forbid::FBD_FORBID_TRADE:
					{
						forbid[i].time=time_left;
						ForbidTrade::GetInstance().SetForbidTrade( roleinfo.id, forbid[i] );
					break;
					}
				case Forbid::FBD_FORBID_SELL:
					//send to game? or game get this by itself
					break;
				case Forbid::FBD_FORBID_LOGIN:
					//add to forbid map
					{
						forbid[i].time=time_left;
						ForbidRoleLogin::GetInstance().SetForbidRoleLogin(roleinfo.id, forbid[i]);
					}
					break;	
				case Forbid::FBD_FORBID_CONSIGN:
					{
						forbid[i].time=time_left;
						ForbidConsign::GetInstance().SetForbidConsign(roleinfo.id, forbid[i]);
					}
					break;
			}
		}
	}

	bool Delivery(Manager::Session::ID proxy_sid, const OctetsStream& osArg)
	{
		PlayerIdentityMatchArg arg;
		osArg >> arg;
		LOG_TRACE("PlayerIdentityMatch roleid %d userid %d flag %d localsid %d",
				arg.roleid, arg.userid, arg.flag, arg.localsid);
		bool central = GDeliveryServer::GetInstance()->IsCentralDS();
		if (! (((arg.flag==DS_TO_CENTRALDS||arg.flag==DS_TO_BATTLEMAP||arg.flag==DIRECT_TO_CENTRALDS)&&central) || (arg.flag==CENTRALDS_TO_DS&&!central)))
		{
			Log::log(LOG_ERR, "PlayerIdentityMatch roleid %d userid %d, flag %d error", arg.roleid, arg.userid, arg.flag);
			SetResult(PlayerIdentityMatchRes(-1));
			SendToSponsor();
			return false;
		}
		//与UserLogin.hrp保持一致
		UserInfo * pinfo = UserContainer::GetInstance().FindUser(arg.userid);
		if(pinfo)
		{
			SetResult(PlayerIdentityMatchRes(ERR_MULTILOGIN));
			SendToSponsor();
			return false;
		}
		if (!ForbidLogin::GetInstance().IsLoginAllowedGlobal())
		{
			SetResult(PlayerIdentityMatchRes(ERR_SRVMAINTAIN));
			SendToSponsor();
			return false;	
		}
/*
		//此处不再判断服务器人数上限 以TryChangeDS和TryRemoteLogin为准
		if ( UserContainer::GetInstance().Size() >= UserContainer::GetInstance().GetPlayerLimit() )
		{
			SetResult(PlayerIdentityMatchRes(ERR_SERVEROVERLOAD));
			SendToSponsor();
			return false;
		}	
*/
		UserIdentityCache::Identity iden;
		if (!UserIdentityCache::GetInstance()->Find(arg.userid, iden))
		{
			Log::log(LOG_ERR, "PlayerIdentityMatch roleid %d userid %d identity timeout", arg.roleid, arg.userid);
			SetResult(PlayerIdentityMatchRes(ERR_IDENTITY_TIMEOUT));
			SendToSponsor();
			return false;
		}
//		UserIdentityCache::GetInstance()->Remove(arg.userid); //Clear Cache
		if (iden.roleid != arg.roleid || iden.src_zoneid != arg.src_zoneid
			/*|| iden.ip != arg.ip 不再验证 ip 玩家出口 IP 可能变化*/ || iden.rand_key != arg.random)
		{
			Log::log(LOG_ERR, "PlayerIdentityMatch userid %d identity(roleid-src_zoneid-ip-randkey.size) Client(%d-%d-%d-%d) does not match Server(%d-%d-%d-%d)", arg.userid, arg.roleid, arg.src_zoneid, arg.ip, arg.random.size(), iden.roleid, iden.src_zoneid, iden.ip, iden.rand_key.size());
			SetResult(PlayerIdentityMatchRes(ERR_IDENTITY_NOTMATCH));
			SendToSponsor();
			return false;
		}
		LOG_TRACE("PlayerIdentityMatch userid %d roleid %d match success", arg.userid, arg.roleid);
		//AU传来的全游戏封禁玩家列表 跨服上可能不存在 通过在原服封禁 让玩家在原服上就不能登录成功
		/*
		GRoleForbid	forbid;
		if( ForbidLogin::GetInstance().GetForbidLogin( arg.userid, forbid ) )
		{
			GDeliveryServer::GetInstance()->Send(proxy_sid,AnnounceForbidInfo(arg.userid,arg.localsid,forbid));
			SetResult(PlayerIdentityMatchRes(ERR_ACCOUNTFORBID));
			SendToSponsor();
			return false;	
		}
		*/
		if (ForbiddenUsers::GetInstance().IsExist(arg.userid))
		{
			SetResult(PlayerIdentityMatchRes(ERR_ACCOUNTLOCKED));
			SendToSponsor();
			return false;
		}
		if (RemoteLoggingUsers::GetInstance().IsExist(arg.userid))
		{
			SetResult(PlayerIdentityMatchRes(ERR_ACCOUNTLOCKED));
			SendToSponsor();
			return false;
		}

		if( GameDBClient::GetInstance()->SendProtocol( *this ) )
		{
			return true;
		}
		else
		{
			SetResult(PlayerIdentityMatchRes(ERR_DELIVER_SEND));
			SendToSponsor();
			return false;
		}
	}

	void PostProcess(Manager::Session::ID proxy_sid,const OctetsStream& osArg, const OctetsStream& osRes)
	{
		PlayerIdentityMatchArg arg;
		osArg >> arg;
		PlayerIdentityMatchRes res;
		osRes >> res;
		LOG_TRACE("PlayerIdentityMatch roleid %d userid %d, retcode=%d", arg.roleid, arg.userid, res.retcode);
		if (res.retcode != ERR_SUCCESS)
		{
			SetResult(&res);
			return;
		}
		/*
		bool useronline=false;
		unsigned int _localsid=0;
		{
			Thread::RWLock::RDScoped l(UserContainer::GetInstance().GetLocker());
			UserInfo * pinfo = UserContainer::GetInstance().FindUser(arg.userid);
			useronline = ( NULL!=pinfo );
			if (useronline) _localsid = pinfo->localsid;
		}
		if ( useronline )
		{
			LOG_TRACE("UserLogin: kick out previous login, userid=%d", arg.userid); 
			KickoutUser ku(arg.userid,_localsid);
			ku.Process(NULL,0); //Process中还会对gdsm->locker_map加锁，因此不能放在Thread::RWLock::WRScoped中
		}
		*/
		if (res.user.cash < 0)
		{
			Log::log(LOG_ERR, "PlayerIdentityMatch, invalid account, userid %d cash %d money %d", arg.userid, res.user.cash, res.user.money);
			res.retcode = -2;
			SetResult(&res);
			return;
		}
/*
		GRoleForbid forbid;
		if (GetUser::CheckUserForbid(res.user, forbid))
		{
			Log::log(LOG_ERR, "PlayerIdentityMatch, Userid %d is forbid", arg.userid);
//			GDeliveryServer::GetInstance()->Send(proxy_sid, AnnounceForbidInfo(arg->userid, arg.localsid, forbid, 1));
			res.retcode = -3;
			SetResult(&res);
			return;
		}
*/
		UserIdentityCache::Identity iden;
		if (!UserIdentityCache::GetInstance()->Find(arg.userid, iden))
		{
			Log::log(LOG_ERR, "PlayerIdentityMatch(res) roleid %d userid %d identity timeout", arg.roleid, arg.userid);
			res.retcode = ERR_IDENTITY_TIMEOUT;
			SetResult(&res);
			return;
		}
		UserIdentityCache::GetInstance()->Remove(arg.userid); //Clear Cache
		HandleRoleForbid(res.roleinfo);
		UserContainer::GetInstance().UserLogin(arg.userid,proxy_sid, arg.localsid, iden.au_isgm, iden.au_func, iden.au_funcparm, arg.ip, iden.iseckey, iden.oseckey, iden.account, false);
		res.iseckey = iden.iseckey;
		res.oseckey = iden.oseckey;
		res.account = iden.account;
		res.zoneid = GDeliveryServer::GetInstance()->zoneid;
		res.district_id = GDeliveryServer::GetInstance()->district_id;

		UserInfo* userinfo=UserContainer::GetInstance().FindUser(arg.userid);
		if (NULL==userinfo) 
			return; 
		//增加超时以保证与原服 userinfo 状态的同步 解决玩家被永久卡在跨服的情况
		if (arg.flag == DS_TO_CENTRALDS || arg.flag == DS_TO_BATTLEMAP || arg.flag == DIRECT_TO_CENTRALDS)
			RemoteLoggingUsers::GetInstance().Push(arg.userid, arg.roleid, userinfo->status);
		/*******与GetUser保持一致*********/
		StockExchange::Instance()->OnLogin(arg.userid, res.user.cash, res.user.money, res.user.cash_buy, res.user.cash_sell, res.user.exg_log, res.user.cash_password);
		userinfo->rolelist=UserInfo::RoleList(res.user.rolelist);
		userinfo->rolelist.SeekToBegin();
		userinfo->logicuid = res.user.logicuid;
		userinfo->logintime = iden.logintime;
		userinfo->autolock = res.user.autolock;
		userinfo->lastlogin_ip = res.user.lastlogin_ip;
		userinfo->src_zoneid = res.roleinfo.src_zoneid;
		if (res.user.referrer)
			userinfo->real_referrer = res.user.referrer;
		userinfo->privileges = iden.auth;
		if (iden.au_isgm != 0 && iden.auth.size() > 0)
			LinkServer::GetInstance().BroadcastProtocol(QueryUserPrivilege_Re(arg.userid, iden.auth));
		if (iden.forbid_talk.time > 0)
			LinkServer::GetInstance().BroadcastProtocol(GMShutup(_ROLE_INVALID, _SID_INVALID, arg.userid, iden.forbid_talk.time, iden.forbid_talk.reason));
		UserContainer::GetInstance().InsertLogicuid(arg.userid, userinfo->logicuid);
		/*********************************/
		RoleInfoCache::Instance().Insert(arg.roleid, res.roleinfo);
		RoleInfoCache::Instance().ClearInexistent(arg.roleid);
		/*
			if (res.blIsGM != 0)
		{
			GAuthClient::GetInstance()->SendProtocol(QueryUserPrivilege2(arg.userid,gdsm->zoneid));
		}
		*/
		SetResult( &res ); // if you modified res, do not forget to call this. 
		STAT_MIN5("Login", 1);
	}

	void OnTimeout( const OctetsStream & osArg )
	{
		PlayerIdentityMatchArg arg;
		osArg >> arg;
		LOG_TRACE("PlayerIdentityMatch timeout, userid %d roleid %d", arg.userid, arg.roleid);
	}

};

};
#endif
